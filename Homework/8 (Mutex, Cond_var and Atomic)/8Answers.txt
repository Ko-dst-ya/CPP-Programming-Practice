№1
Есть структура, в которой 3 поля и для неё есть некий инвариант, который может изменяться при работе писателя
(модифицирующая функция-член) и читатель может обнаружить нарушение этого инварианта. Это и есть состояние 
гонки
При инициализации с двойной проверкой может также произойти грязное чтение.
__________________________________________________________________________________________________________________
№2
Для работы с mutex используют lock_guard-ы, в которых зашито парное действие блокировки-разблокировки.
conditional_var - способ многоразового ожидания события. Для работы с conditional_var используют unique_lock 
__________________________________________________________________________________________________________________
№3
Гранулярность блокировки (мелкость разбиения) влияет на производительность (у мелкой высокая производительность).
__________________________________________________________________________________________________________________
№4
Есть список и два потока, поток A проходит ->, а B <- => они заблокируют друг друга (deadlock)
Предотвращение проблемы:
1) std::lock захват нескольких mutex-ов одновременно
2) Проверка + ожидание - опирается на время (блокнутый mutex ждём на блокировке и если мы ждём больше какого-то времени,
то mutex принудительно разблокируется)
3) Захват mutex-ов в одинаковом порядке
4) Расстановка приоритетов
__________________________________________________________________________________________________________________
№5
Атомарная (неделимая) операция обеспечивает транзакционное поведение, т.е. либо полностью выполняется, либо не 
выполняется (ex: load, store, exchange...)

Атомарный тип данных (АТД) : данные состоят из объектов, которые хранятся в ячейках памятиБ с которыми можно
работать как с атомарными объектами.
С помощью АТД можно добиться максимальной мелкости разбиени, особенно хорошо, если тип без блокировки.