№1
Контекстный параллелизм (как возникает)
1 исполнитель может выполнять мнимый параллелизм, т.е. он выполняет несколько задач, переключаясь между ними,
но выигрыша по времени не получится, а только проигрыш из-за переключений. Это и есть явление контекстного параллелизма
________________________________________________________________________________________________________________________
№2
Основные подходы к организации параллелизма:
1) На процессах:
		безопасность	+
		скорость		-
		сложность		-
		затратность		-

2) На потоках:
		безопасность	- 	(грязное чтение)
		скорость 		+		
		сложность 		+ 	(STD)
		затратность 	+-	(для создания процесса требуется больше ресурсов, чем для создания потока внутри процесса)
		[затратность - это кол-во выделенных ресурсов для создания процесса/потока]
	
________________________________________________________________________________________________________________________
№3
На производительность параллельных алгоритмов влияют:
1) Кол-во исполнителей (контекстное переключение)
2) Конкуренция за данные (перебрасывание кэша)
3) Ложное заделение (низкоуровнево)
4) Доля последовательных участков программы (из закона Амдала)
________________________________________________________________________________________________________________________
№4
В стандартной библиотеке концепция асинхронного исполнения реализована посредством future (std::future - будущий результат,
создание асинхронной задачи - std::async, запрос реультата посредством .get() - только один раз => wait, valid)
________________________________________________________________________________________________________________________
№5
Что нужно учитывать при замене последовательной реализации алгоритма на параллельную:
1) Кол-во данных, ложность команд (+ - просто, sin - сложно)
2) Время подготовки
3) Характер задачи (если много параллельных участов, то параллелизм, если много последовательных, то последовательная (з-н Амдала)
4) Работа с памятью

Это определяется только по таймеру, но не на глаз!
